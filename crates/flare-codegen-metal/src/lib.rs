pub mod error;
pub mod expr;
pub mod kernel;
pub mod stmt;
pub mod types;

use error::{CodegenError, Result};
use flare::ast::{Program, Stmt};
use kernel::{KernelConfig, KernelGenerator};
use std::fmt::Write;

#[derive(Debug, Clone)]
pub struct CodegenOptions {
    pub kernel_config: KernelConfig,

    pub emit_comments: bool,

    pub pretty_print: bool,

    pub metal_version: String,

    pub include_metal_stdlib: bool,
}

impl Default for CodegenOptions {
    fn default() -> Self {
        Self {
            kernel_config: KernelConfig::default(),
            emit_comments: true,
            pretty_print: true,
            metal_version: "2.4".to_string(),
            include_metal_stdlib: true,
        }
    }
}

pub struct MetalCodegen {
    options: CodegenOptions,

    kernel_gen: KernelGenerator,
}

impl MetalCodegen {
    pub fn new() -> Self {
        Self::with_options(CodegenOptions::default())
    }

    pub fn with_options(options: CodegenOptions) -> Self {
        let kernel_gen = KernelGenerator::with_config(options.kernel_config.clone());
        Self {
            options,
            kernel_gen,
        }
    }

    pub fn generate(&mut self, program: &Program) -> Result<String> {
        let mut output = String::new();

        self.generate_header(&mut output)?;

        let mut kernels = Vec::new();
        let mut schedules = std::collections::HashMap::new();

        for stmt in &program.items {
            match stmt {
                Stmt::Kernel(kernel) => {
                    kernels.push(kernel);
                }
                Stmt::Schedule(schedule) => {
                    if let Some(target) = schedule.target {
                        schedules.insert(target, schedule);
                    }
                }
                Stmt::Fusion(_) => {}
                _ => {
                    return Err(CodegenError::statement_error(
                        "only kernel, schedule, and fusion statements allowed at top level",
                        stmt.span(),
                    ));
                }
            }
        }

        for kernel in kernels {
            let schedule = schedules.get(kernel.name).copied();
            let kernel_code = self.kernel_gen.generate(kernel, schedule)?;
            writeln!(&mut output, "{}", kernel_code)?;
        }

        Ok(output)
    }

    fn generate_header(&self, output: &mut String) -> Result<()> {
        if self.options.emit_comments {
            writeln!(output, "// generated by Flare")?;
            writeln!(output)?;
        }

        if self.options.include_metal_stdlib {
            writeln!(output, "#include <metal_stdlib>")?;
            writeln!(output, "using namespace metal;")?;
            writeln!(output)?;
        }

        Ok(())
    }

    pub fn metal_version(&self) -> &str {
        &self.options.metal_version
    }

    pub fn kernel_config(&self) -> &KernelConfig {
        &self.options.kernel_config
    }
}

impl Default for MetalCodegen {
    fn default() -> Self {
        Self::new()
    }
}

pub fn compile(program: &Program) -> Result<String> {
    let mut codegen = MetalCodegen::new();
    codegen.generate(program)
}

pub fn compile_with_options(program: &Program, options: CodegenOptions) -> Result<String> {
    let mut codegen = MetalCodegen::with_options(options);
    codegen.generate(program)
}

#[cfg(test)]
mod tests {
    use super::*;
    use flare::Flare;

    #[test]
    fn test_matmul_naive_metal_codegen() {
        let source = r#"
            kernel matmul_naive(A: Tensor<f32, [M, K]>, B: Tensor<f32, [K, N]>) -> Tensor<f32, [M, N]> {
                grid: [M, N]
                block: [1]

                compute {
                    let row = block_idx.y
                    let col = block_idx.x
                    var sum: f32 = 0.0

                    for k in 0..K {
                        sum = sum + A[row, k] * B[k, col]
                    }

                    output[row, col] = sum
                }
            }
        "#;

        let program = Flare::compile_from_string(source).expect("failed to parse kernel");
        let metal_code = compile(&program).expect("failed to generate Metal code");
    }
}
